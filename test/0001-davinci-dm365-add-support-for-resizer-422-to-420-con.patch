From 1b1b3edac93eb6a5fe1d327a40403e8b8edde32c Mon Sep 17 00:00:00 2001
From: Manjunath Hadli <manjunath.hadli@ti.com>
Date: Thu, 23 Feb 2012 09:45:34 +0530
Subject: [PATCH] davinci: dm365: add support for resizer 422 to 420 conversion

Signed-off-by: Manjunath Hadli <manjunath.hadli@ti.com>
---
 mc/dm365/resizer_ss.c |  165 +++++++++++++++++++------------------------------
 1 files changed, 64 insertions(+), 101 deletions(-)

diff --git a/mc/dm365/resizer_ss.c b/mc/dm365/resizer_ss.c
index 223750a..0b897fa 100644
--- a/mc/dm365/resizer_ss.c
+++ b/mc/dm365/resizer_ss.c
@@ -180,27 +180,6 @@ int allocate_user_buffers(int in_buf_size, int out1_buf_size, int out2_buf_size)
 			(void *)output1_buffers[i]->phy_addr);
 	}
 	printf("**********************************************\n");
-/* TODO:enable this with rsz-b enable*/
-// 	printf("Allocating output2 buffers :buf size = %d \n", out2_buf_size);
-//
-// 	for (i=0; i < APP_NUM_BUFS; i++) {
-// 		output2_buffers[i].user_addr = CMEM_alloc(out2_buf_size, &alloc_params);
-// 		if (output2_buffers[i].user_addr) {
-// 			output2_buffers[i].phy_addr = CMEM_getPhys(output2_buffers[i].user_addr);
-// 			if (0 == output2_buffers[i].phy_addr) {
-// 				printf("Failed to get phy cmem buffer address\n");
-// 				return -1;
-// 			}
-// 		} else {
-// 			printf("Failed to allocate cmem buffer\n");
-// 			return -1;
-// 		}
-// 		printf("Got %p from CMEM, phy = %p\n", output2_buffers[i].user_addr,
-// 			(void *)output2_buffers[i].phy_addr);
-// 	}
-//
-// 	printf("**********************************************\n");
-
 
 	return 0;
 }
@@ -223,7 +202,7 @@ int main(int argc, char *argp[])
 	struct imp_buffer buf_out1[3];
 	struct imp_buffer buf_out2[3];
 	struct imp_convert convert;
-	int i,j;
+	int i,j,h, num_bytes;
 	char in_file[100] = "";
 	FILE *inp_f = NULL, *outp1_f = NULL, *outp2_f = NULL;
 	int width = INPUT_WIDTH, height = INPUT_HEIGHT, size;
@@ -294,7 +273,6 @@ int main(int argc, char *argp[])
 
 	printf("doing resize on in_file = %s and writing out to out_file1 = %s out_file2 = %s\n",
 		in_file,OUTPUT1_FILE, OUTPUT2_FILE);
-	//oper_mode = IMP_MODE_SINGLE_SHOT;
 
 	printf("starting\n");
 	inp_f = fopen(in_file, "rb");
@@ -326,9 +304,11 @@ int main(int argc, char *argp[])
 	code = V4L2_MBUS_FMT_YUYV8_2X8;
 
 	if (out_format) {
-		output1_size = width * height * 1.5;
+		int pitch = ALIGN(width, 32);
+
+		output1_size =  pitch * height * 1.5;
 		output2_size = 640 * 480 * 1.5;
-		//code = TODO add for nv12
+		code = V4L2_MBUS_FMT_NV12_1X20;
 	}
 
 	if (size != (INPUT_WIDTH * INPUT_HEIGHT * BYTESPERLINE)) {
@@ -510,6 +490,47 @@ int main(int argc, char *argp[])
 		goto out;
 	}
 
+	/* set format on pad of rsz */
+	/* 18. set format on sink-pad of rsz */
+	printf("10. setting format on sink-pad of rsz entity. . . \n");
+	memset(&fmt, 0, sizeof(fmt));
+
+	fmt.pad = P_RSZ_SINK;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.code = code;
+	fmt.format.width = INPUT_WIDTH;
+	fmt.format.height = INPUT_HEIGHT;
+	fmt.format.field = V4L2_FIELD_NONE;
+
+	ret = ioctl(resizer_fd, VIDIOC_SUBDEV_S_FMT, &fmt);
+	if(ret) {
+		printf("1: failed to set format on pad %x\n", fmt.pad);
+		goto out;
+	}
+	else
+		printf("successfully format is set on pad %x\n", fmt.pad);
+
+	
+	/* 19. set format on source-pad of rsz */
+	printf("10. setting format on source-pad of rsz entity. . . \n");
+	memset(&fmt, 0, sizeof(fmt));
+
+	fmt.pad = P_RSZ_SOURCE;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.code = code;
+	fmt.format.width = width;
+	fmt.format.height = height;
+	fmt.format.field = V4L2_FIELD_NONE;
+
+	ret = ioctl(resizer_fd, VIDIOC_SUBDEV_S_FMT, &fmt);
+	if(ret) {
+		printf("2: failed to set format on pad %x\n", fmt.pad);
+		goto out;
+	}
+	else
+		printf("successfully format is set on pad %x\n", fmt.pad);
+
+
 	printf("Setting default configuration in Resizer\n");
 	bzero(&rsz_ss_config, sizeof(struct rsz_single_shot_config));
 	//rsz_chan_config.oper_mode = IMP_MODE_SINGLE_SHOT;
@@ -579,46 +600,6 @@ int main(int argc, char *argp[])
 		goto out;
 	}
 
-	/* set format on pad of rsz */
-	/* 18. set format on sink-pad of rsz */
-	printf("10. setting format on sink-pad of rsz entity. . . \n");
-	memset(&fmt, 0, sizeof(fmt));
-
-	fmt.pad = P_RSZ_SINK;
-	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	fmt.format.code = code;
-	fmt.format.width = INPUT_WIDTH;
-	fmt.format.height = INPUT_HEIGHT;
-	fmt.format.field = V4L2_FIELD_NONE;
-
-	ret = ioctl(resizer_fd, VIDIOC_SUBDEV_S_FMT, &fmt);
-	if(ret) {
-		printf("failed to set format on pad %x\n", fmt.pad);
-		goto out;
-	}
-	else
-		printf("successfully format is set on pad %x\n", fmt.pad);
-
-	/* 19. set format on source-pad of rsz */
-	printf("10. setting format on source-pad of rsz entity. . . \n");
-	memset(&fmt, 0, sizeof(fmt));
-
-	fmt.pad = P_RSZ_SOURCE;
-	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	fmt.format.code = code;
-	fmt.format.width = width;
-	fmt.format.height = height;
-	fmt.format.field = V4L2_FIELD_NONE;
-
-	ret = ioctl(resizer_fd, VIDIOC_SUBDEV_S_FMT, &fmt);
-	if(ret) {
-		printf("failed to set format on pad %x\n", fmt.pad);
-		goto out;
-	}
-	else
-		printf("successfully format is set on pad %x\n", fmt.pad);
-
-
 	if (allocate_user_buffers(size, output1_size, output2_size) < 0) {
 		perror("Error in allocating user buffers\n");
 		ret = -1;
@@ -629,30 +610,6 @@ int main(int argc, char *argp[])
 	for(i = 0; i < APP_NUM_BUFS; i++)
 		memcpy(input_buffers[i]->user_addr, in_buf, size);
 
-// 	bzero(&convert,sizeof(convert));
-// 	bzero(output1_buffer.user_addr, output1_size);
-// 	memcpy(input_buffer.user_addr, in_buf, size);
-// 	convert.in_buff.buf_type = IMP_BUF_IN;
-// 	convert.in_buff.index = -1;
-// 	convert.in_buff.offset = (unsigned int)input_buffer.user_addr;
-// 	convert.in_buff.size = size;
-// 	convert.out_buff1.buf_type = IMP_BUF_OUT1;
-// 	convert.out_buff1.index = -1;
-// 	convert.out_buff1.offset = (unsigned int)output1_buffer.user_addr;
-// 	convert.out_buff1.size = output1_size;
-// 	if (second_output) {
-// 		bzero(output2_buffer.user_addr, output2_size);
-// 		convert.out_buff2.buf_type = IMP_BUF_OUT2;
-// 		convert.out_buff2.index = -1;
-// 		convert.out_buff2.offset = (unsigned int)output2_buffer.user_addr;
-// 		convert.out_buff2.size = output2_size;
-// 	}
-// 	if (ioctl(resizer_fd, RSZ_RESIZE, &convert) < 0) {
-// 		perror("Error in doing preview\n");
-// 		ret = -1;
-// 		goto out;
-// 	}
-
 
 	if ((vidin_fd = open("/dev/video3", O_RDWR | O_NONBLOCK, 0)) <= -1) {
 		printf("failed to open %s \n", "/dev/video3");
@@ -675,7 +632,7 @@ int main(int argc, char *argp[])
 	v4l2_fmt.fmt.pix.field = V4L2_FIELD_NONE;
 
 	if (-1 == ioctl(vidin_fd, VIDIOC_S_FMT, &v4l2_fmt)) {
-		printf("failed to set format on video-in device \n");
+		printf("3: failed to set format on video-in device \n");
 		goto out;
 	} else
 		printf("successfully set the format\n");
@@ -686,11 +643,14 @@ int main(int argc, char *argp[])
 	v4l2_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	v4l2_fmt.fmt.pix.width = width;
 	v4l2_fmt.fmt.pix.height = height;
-	v4l2_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+	if (out_format)
+		v4l2_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;
+	else
+		v4l2_fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
 	v4l2_fmt.fmt.pix.field = V4L2_FIELD_NONE;
 
 	if (-1 == ioctl(vidout_fd, VIDIOC_S_FMT, &v4l2_fmt)) {
-		printf("failed to set format on captute device \n");
+		printf("4 :failed to set format on captute device \n");
 		goto out;
 	} else
 		printf("successfully set the format\n");
@@ -796,13 +756,6 @@ int main(int argc, char *argp[])
 		printf("streaming started successfully\n");
 
 
-	if (out_format)
-		size = width * height * 1.5;
-	else
-		size = width * height * 2;
-
-	printf("size = %d\n", size);
-
 	/* 36.get 5 frames from capture device and store in a file */
 	frame_count = 0;
 
@@ -837,12 +790,22 @@ try2_again:
 		temp = cap_buf.m.userptr;
 		source = (char *)temp;
 
+		if (out_format) {
+			h = height + height/2;
+			num_bytes = width;
+		}
+		else {
+			h = height;
+			num_bytes = width*2;
+		}
+
 		/* copy frame to a file */
-		for(i=0 ; i < height; i++) {
-			fwrite(source, 1 , width*2, outp1_f);
+		for(i=0 ; i < h; i++) {
+			fwrite(source, 1 , num_bytes, outp1_f);
 			source += capture_pitch;
 		}
 
+
 		ret = ioctl(vidin_fd, VIDIOC_QBUF, &input_buf);
 		if (ret < 0) {
 			printf("failed to Q buffer onto vid-in device, ret = %x\n", ret);
-- 
1.7.4.1

